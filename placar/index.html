<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <meta
    name="viewport"
    content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
  />
  <title>Placar Interativo</title>
  <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Crect x='0' y='0' width='50' height='100' fill='%23c0392b'/%3E%3Crect x='50' y='0' width='50' height='100' fill='%232980b9'/%3E%3Cg stroke='white' stroke-width='7' fill='none'%3E%3Ccircle cx='50' cy='50' r='38'/%3E%3Cpath d='M50,12 A60,40 0 0,0 50,88'/%3E%3Cpath d='M12,50 A40,60 0 0,1 88,50'/%3E%3C/g%3E%3C/svg%3E" type="image/svg+xml">
  <!-- Importa o Vue.js via CDN -->
  <script src="//unpkg.com/vue@3/dist/vue.global.js"></script>
  <link rel="preconnect" href="//fonts.googleapis.com" />
  <link rel="preconnect" href="//fonts.gstatic.com" crossorigin />
  <!-- Fonte Roboto Mono -->
  <link
    href="//fonts.googleapis.com/css2?family=Roboto+Mono:wght@700&display=swap"
    rel="stylesheet"
  />
  <style>
    /* Reseta estilos básicos e define a fonte */
    html,
    body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden; /* Evita barras de rolagem */
      font-family: "Roboto Mono", monospace;
      background-color: #111;
    }

    /* Regra geral para transições suaves e rápidas */
    * {
      transition: all 0.2s ease-in-out;
    }

    #fullscreen-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background-color: rgba(0, 0, 0, 0.85); /* Fundo escuro semi-transparente */
      z-index: 9999; /* Garante que está acima de tudo */
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      opacity: 1; /* Para transição */
    }

    #fullscreen-overlay.hidden {
      opacity: 0;
      pointer-events: none; /* Impede cliques quando escondido */
    }

    #fullscreen-button {
      background-color: #2980b9;
      border: 2px solid #3498db;
      color: white;
      padding: 20px 40px;
      font-family: "Roboto Mono", monospace;
      font-size: 24px;
      font-weight: bold;
      border-radius: 12px;
      cursor: pointer;
    }
    #fullscreen-button:hover {
      background-color: #3498db;
    }
    #fullscreen-button:active {
      transform: scale(0.95);
    }

    #rotation-wrapper {
      width: 100%;
      height: 100%;
    }

    /* Força a orientação paisagem apenas em dispositivos de toque (celulares/tablets).
    */
    @media (orientation: portrait) and (hover: none) and (pointer: coarse) {
      #rotation-wrapper {
        transform: rotate(-90deg);
        transform-origin: left top;
        width: 100vh;
        height: 100vw;
        overflow: hidden;
        position: absolute;
        top: 100%;
        left: 0;
      }
      .score {
        font-size: 80vw !important;
      }
    }

    #app {
      width: 100%;
      height: 100%;
      display: flex;
      justify-content: center;
      align-items: center;
      position: relative;
    }

    .scoreboard {
      display: flex;
      width: 100%;
      height: 100%;
    }

    .team {
      flex: 1;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      color: white;
      position: relative;
      user-select: none;
      cursor: pointer;
    }

    .team-a { background-color: #c0392b; }
    .team-b { background-color: #2980b9; }

    .team-name {
      font-size: 5vh;
      font-weight: bold;
      text-transform: uppercase;
      position: absolute;
      top: 5%;
      cursor: pointer; /* Indica que o nome é clicável */
      z-index: 10; /* Garante que o nome esteja acima da área de clique do placar */
    }

    .score {
      font-size: 100vh;
      font-weight: bold;
      line-height: 1;
    }

    .timer-container {
      position: absolute;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 10;
      background-color: rgba(0, 0, 0, 0.4);
      padding: 5px 25px;
      border-radius: 20px;
      border: 2px solid rgba(255, 255, 255, 0.2);
      cursor: pointer; /* Adicionado para indicar que é clicável */
    }

    .timer-container.timer-paused {
      background-color: #e67e22; /* Laranja */
      border-color: #f39c12;
    }

    .timer-display {
      font-size: 4vh;
      color: white;
      font-weight: bold;
    }

    .timer-container.timer-paused .timer-display {
      font-size: 8vh; /* Dobro da fonte quando pausado */
    }

    .controls {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 10;
    }

    .reset-button {
      background-color: rgba(255, 255, 255, 0.2);
      border: 2px solid rgba(255, 255, 255, 0.5);
      color: white;
      border-radius: 50%;
      width: 50px;
      height: 50px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .reset-button:hover {
      background-color: rgba(255, 255, 255, 0.4);
    }

    .reset-button svg {
      width: 28px;
      height: 28px;
    }
  </style>
</head>
<body>

<div id="fullscreen-overlay" class="hidden">
  <button id="fullscreen-button" onclick="handleFullscreenRequest()">Entrar em Tela Cheia</button>
</div>

<!-- SCRIPT ISOLADO E GLOBAL PARA TELA CHEIA -->
<script>
  function handleFullscreenRequest() {
    const docEl = document.documentElement;
    if (docEl.requestFullscreen) {
      docEl.requestFullscreen();
    } else if (docEl.webkitRequestFullscreen) {
      docEl.webkitRequestFullscreen();
    }
  }

  function updateFullscreenUI() {
    const overlay = document.getElementById('fullscreen-overlay');
    if (!overlay) return;

    // document.fullscreenElement será nulo se não estiver em tela cheia
    if (document.fullscreenElement || document.webkitFullscreenElement) {
      overlay.classList.add('hidden');
    } else {
      overlay.classList.remove('hidden');
    }
  }

  document.addEventListener('DOMContentLoaded', () => {
    const overlay = document.getElementById('fullscreen-overlay');
    const docEl = document.documentElement;
    if (!docEl.requestFullscreen && !docEl.webkitRequestFullscreen) {
      if (overlay) overlay.remove(); // Remove completamente se a API não existe
    } else {
      // Adiciona os listeners e atualiza a UI para o estado inicial
      document.addEventListener('fullscreenchange', updateFullscreenUI);
      document.addEventListener('webkitfullscreenchange', updateFullscreenUI);
      updateFullscreenUI(); // Chama uma vez para definir o estado correto no carregamento
    }
  });
</script>


<div id="rotation-wrapper">
  <div id="app">
    <div class="timer-container" :class="{ 'timer-paused': !timerIsRunning && timerTotalSeconds > 0 }" @click.stop="swapTeamNames">
      <span class="timer-display">{{ formattedTime }}</span>
    </div>

    <div class="scoreboard">
      <div
        class="team team-a"
        @mousedown.prevent="pressStart('A')"
        @mouseup="pressEnd('A')"
        @touchstart.prevent="pressStart('A')"
        @touchend="pressEnd('A')"
        @contextmenu.prevent
      >
        <div class="team-name" @click.stop="swapTeamNames">{{ teamAName }}</div>
        <div class="score">{{ scoreA }}</div>
      </div>
      <div
        class="team team-b"
        @mousedown.prevent="pressStart('B')"
        @mouseup="pressEnd('B')"
        @touchstart.prevent="pressStart('B')"
        @touchend="pressEnd('B')"
        @contextmenu.prevent
      >
        <div class="team-name" @click.stop="swapTeamNames">{{ teamBName }}</div>
        <div class="score">{{ scoreB }}</div>
      </div>
    </div>

    <div class="controls">
      <button
        @click.stop="resetGame"
        class="reset-button"
        title="Zerar Placar e Pausar Cronômetro"
      >
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="white">
          <path d="M17.65 6.35C16.2 4.9 14.21 4 12 4c-4.42 0-7.99 3.58-7.99 8s3.57 8 7.99 8c3.73 0 6.84-2.55 7.73-6h-2.08c-.82 2.33-3.04 4-5.65 4-3.31 0-6-2.69-6-6s2.69-6 6-6c1.66 0 3.14.69 4.22 1.78L13 11h7V4l-2.35 2.35z"/>
        </svg>
      </button>
    </div>
  </div>
</div>

<script>
  const { createApp } = Vue

  createApp({
    data() {
      return {
        scoreA: 0,
        scoreB: 0,
        teamAName: 'PORTA',
        teamBName: 'Fundo',
        timerTotalSeconds: 0,
        timerIsRunning: false,
        timerId: null,
        wakeLock: null,
        longPressTimer: null,
        isLongPress: false,
        longPressDuration: 500,
      }
    },
    computed: {
      formattedTime() {
        const minutes = Math.floor(this.timerTotalSeconds / 60)
        const seconds = this.timerTotalSeconds % 60
        return `${String(minutes).padStart(2, "0")}:${String(seconds).padStart(2, "0")}`
      },
    },
    methods: {
      swapTeamNames() {
        const tempName = this.teamAName
        this.teamAName = this.teamBName
        this.teamBName = tempName
      },
      resetGame() {
        this.scoreA = 0
        this.scoreB = 0
        this.pauseTimer()
      },
      startTimer() {
        if (this.timerIsRunning) return
        this.timerIsRunning = true
        this.requestWakeLock()
        this.timerId = setInterval(() => { this.timerTotalSeconds++ }, 1000)
      },
      pauseTimer() {
        this.timerIsRunning = false
        clearInterval(this.timerId)
        this.releaseWakeLock()
      },
      async requestWakeLock() {
        if ("wakeLock" in navigator) {
          try {
            this.wakeLock = await navigator.wakeLock.request("screen")
            this.wakeLock.addEventListener("release", () => { console.log("Wake Lock foi liberado pelo sistema.") })
            console.log("Wake Lock está ativo.")
          } catch (err) {
            console.error(`Não foi possível ativar o Wake Lock: ${err.name}, ${err.message}`)
          }
        } else {
          console.log("API Wake Lock não é suportada neste navegador.")
        }
      },
      async releaseWakeLock() {
        if (this.wakeLock !== null) {
          try {
            await this.wakeLock.release()
            this.wakeLock = null
            console.log("Wake Lock foi liberado.")
          } catch (err) {
            console.error(`Falha ao liberar o Wake Lock: ${err.name}, ${err.message}`)
          }
        }
      },
      incrementScore(team) {
        const wasGameAtZero = this.scoreA === 0 && this.scoreB === 0

        if (team === "A") this.scoreA++
        else this.scoreB++

        if (wasGameAtZero) {
          this.timerTotalSeconds = 30
          this.startTimer()
        }
      },
      decrementScore(team) {
        if (team === "A" && this.scoreA > 0) this.scoreA--
        else if (team === "B" && this.scoreB > 0) this.scoreB--
      },
      pressStart(team) {
        this.isLongPress = false
        this.longPressTimer = setTimeout(() => {
          this.decrementScore(team)
          this.isLongPress = true
        }, this.longPressDuration)
      },
      pressEnd(team) {
        clearTimeout(this.longPressTimer)
        if (!this.isLongPress) this.incrementScore(team)
      },
      handleVisibilityChange() {
        if (this.wakeLock !== null && document.visibilityState === "visible") {
          this.requestWakeLock()
        }
      },
    },
    mounted() {
      document.addEventListener("visibilitychange", this.handleVisibilityChange)
    },
    beforeUnmount() {
      this.pauseTimer()
      document.removeEventListener("visibilitychange", this.handleVisibilityChange)
    },
  }).mount("#app")
</script>
</body>
</html>