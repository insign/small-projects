<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <meta
    name="viewport"
    content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
  />
  <title>Placar Interativo</title>
  <!-- Importa o Vue.js via CDN -->
  <script src="//unpkg.com/vue@3/dist/vue.global.js"></script>
  <link rel="preconnect" href="//fonts.googleapis.com" />
  <link rel="preconnect" href="//fonts.gstatic.com" crossorigin />
  <!-- Fonte Roboto Mono -->
  <link
    href="//fonts.googleapis.com/css2?family=Roboto+Mono:wght@700&display=swap"
    rel="stylesheet"
  />
  <style>
    /* Reseta estilos básicos e define a fonte */
    html,
    body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden; /* Evita barras de rolagem */
      font-family: "Roboto Mono", monospace;
      background-color: #111;
    }

    /* Força a orientação paisagem apenas em dispositivos de toque (celulares/tablets).
  (hover: none) e (pointer: coarse) são usados para detectar dispositivos de toque.
*/
    @media (orientation: portrait) and (hover: none) and (pointer: coarse) {
      html {
        /* Gira a tela inteira em dispositivos no modo retrato */
        transform: rotate(-90deg);
        transform-origin: left top;
        width: 100vh;
        height: 100vw;
        overflow-x: hidden;
        position: absolute;
        top: 100%;
        left: 0;
      }
      .score {
        /* No modo retrato rotacionado, a altura disponível passa a ser a LARGURA do viewport (vw).
           Portanto, usamos 80vw para corresponder a 80% da altura da tela. */
        font-size: 80vw !important;
      }
    }

    /* Container principal da aplicação */
    #app {
      width: 100%;
      height: 100%;
      display: flex;
      justify-content: center;
      align-items: center;
      position: relative;
    }

    /* Container do placar */
    .scoreboard {
      display: flex;
      width: 100%;
      height: 100%;
    }

    /* Estilo de cada time */
    .team {
      flex: 1; /* Divide o espaço igualmente */
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      color: white;
      position: relative;
      user-select: none; /* Impede a seleção de texto */
      transition: background-color 0.3s ease;
      cursor: pointer; /* Indica que toda a área é clicável */
    }

    /* Cores de fundo para cada time */
    .team-a {
      background-color: #c0392b; /* Vermelho */
    }

    .team-b {
      background-color: #2980b9; /* Azul */
    }

    /* Nome do time */
    .team-name {
      font-size: 5vh;
      font-weight: bold;
      text-transform: uppercase;
      position: absolute;
      top: 5%;
    }

    /* Estilo da pontuação */
    .score {
      /* Padrão para paisagem/desktop: 100% da altura do viewport */
      font-size: 100vh;
      font-weight: bold;
      line-height: 1;
    }

    /* Container do cronômetro */
    .timer-container {
      position: absolute;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 10;
      background-color: rgba(0, 0, 0, 0.4);
      padding: 5px 25px;
      border-radius: 20px;
      border: 2px solid rgba(255, 255, 255, 0.2);
    }

    .timer-display {
      font-size: 4vh;
      color: white;
      font-weight: bold;
    }

    /* Container para os botões de controle */
    .controls {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 10;
    }

    /* Estilo do botão de reset */
    .reset-button {
      background-color: rgba(255, 255, 255, 0.2);
      border: 2px solid rgba(255, 255, 255, 0.5);
      color: white;
      border-radius: 50%;
      width: 50px;
      height: 50px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: background-color 0.2s;
    }

    .reset-button:hover {
      background-color: rgba(255, 255, 255, 0.4);
    }

    .reset-button svg {
      width: 28px;
      height: 28px;
    }
  </style>
</head>
<body>
<div id="app">
  <!-- Cronômetro -->
  <div class="timer-container">
    <span class="timer-display">{{ formattedTime }}</span>
  </div>

  <div class="scoreboard">
    <!-- Seção do Time A -->
    <div
      class="team team-a"
      @mousedown.prevent="pressStart('A')"
      @mouseup="pressEnd('A')"
      @touchstart.prevent="pressStart('A')"
      @touchend="pressEnd('A')"
      @contextmenu.prevent
    >
      <div class="team-name">PORTA</div>
      <div class="score">{{ scoreA }}</div>
    </div>

    <!-- Seção do Time B -->
    <div
      class="team team-b"
      @mousedown.prevent="pressStart('B')"
      @mouseup="pressEnd('B')"
      @touchstart.prevent="pressStart('B')"
      @touchend="pressEnd('B')"
      @contextmenu.prevent
    >
      <div class="team-name">Fundo</div>
      <div class="score">{{ scoreB }}</div>
    </div>
  </div>

  <!-- Botões de Controle -->
  <div class="controls">
    <button
      @click.stop="resetGame"
      class="reset-button"
      title="Zerar Placar e Pausar Cronômetro"
    >
      <svg
        xmlns="http://www.w3.org/2000/svg"
        viewBox="0 0 24 24"
        fill="white"
      >
        <path
          d="M17.65 6.35C16.2 4.9 14.21 4 12 4c-4.42 0-7.99 3.58-7.99 8s3.57 8 7.99 8c3.73 0 6.84-2.55 7.73-6h-2.08c-.82 2.33-3.04 4-5.65 4-3.31 0-6-2.69-6-6s2.69-6 6-6c1.66 0 3.14.69 4.22 1.78L13 11h7V4l-2.35 2.35z"
        />
      </svg>
    </button>
  </div>
</div>

<script>
  const { createApp } = Vue

  createApp({
    data() {
      return {
        scoreA: 0,
        scoreB: 0,
        timerTotalSeconds: 0,
        timerIsRunning: false,
        timerId: null,
        wakeLock: null,
        longPressTimer: null,
        isLongPress: false,
        longPressDuration: 500, // 500ms para considerar long press
      }
    },
    computed: {
      formattedTime() {
        const minutes = Math.floor(this.timerTotalSeconds / 60)
        const seconds = this.timerTotalSeconds % 60
        return `${String(minutes).padStart(2, "0")}:${String(
          seconds,
        ).padStart(2, "0")}`
      },
    },
    methods: {
      resetGame() {
        this.scoreA = 0
        this.scoreB = 0
        this.pauseTimer()
      },
      startTimer() {
        if (this.timerIsRunning) return
        this.timerIsRunning = true
        this.requestWakeLock()
        this.timerId = setInterval(() => {
          this.timerTotalSeconds++
        }, 1000)
      },
      pauseTimer() {
        this.timerIsRunning = false
        clearInterval(this.timerId)
        this.releaseWakeLock()
      },
      async requestWakeLock() {
        if ("wakeLock" in navigator) {
          try {
            this.wakeLock =
              await navigator.wakeLock.request("screen")
            this.wakeLock.addEventListener(
              "release",
              () => {
                console.log(
                  "Wake Lock foi liberado pelo sistema.",
                )
              },
            )
            console.log("Wake Lock está ativo.")
          } catch (err) {
            console.error(
              `Não foi possível ativar o Wake Lock: ${err.name}, ${err.message}`,
            )
          }
        } else {
          console.log(
            "API Wake Lock não é suportada neste navegador.",
          )
        }
      },
      async releaseWakeLock() {
        if (this.wakeLock !== null) {
          try {
            await this.wakeLock.release()
            this.wakeLock = null
            console.log("Wake Lock foi liberado.")
          } catch (err) {
            console.error(
              `Falha ao liberar o Wake Lock: ${err.name}, ${err.message}`,
            )
          }
        }
      },
      incrementScore(team) {
        const wasGameAtZero =
                this.scoreA === 0 && this.scoreB === 0

        if (team === "A") {
          this.scoreA++
        } else {
          this.scoreB++
        }

        if (wasGameAtZero) {
          this.timerTotalSeconds = 0
          this.startTimer()
        }
      },
      decrementScore(team) {
        if (team === "A" && this.scoreA > 0) {
          this.scoreA--
        } else if (team === "B" && this.scoreB > 0) {
          this.scoreB--
        }
      },
      // Inicia a contagem para o "long press"
      pressStart(team) {
        this.isLongPress = false
        this.longPressTimer = setTimeout(() => {
          this.decrementScore(team)
          this.isLongPress = true
        }, this.longPressDuration)
      },
      // Finaliza a ação (clique curto ou long press)
      pressEnd(team) {
        clearTimeout(this.longPressTimer)
        if (!this.isLongPress) {
          this.incrementScore(team)
        }
      },
      handleVisibilityChange() {
        if (
          this.wakeLock !== null &&
          document.visibilityState === "visible"
        ) {
          this.requestWakeLock()
        }
      },
    },
    mounted() {
      document.addEventListener(
        "visibilitychange",
        this.handleVisibilityChange,
      )
    },
    beforeUnmount() {
      this.pauseTimer()
      document.removeEventListener(
        "visibilitychange",
        this.handleVisibilityChange,
      )
    },
  }).mount("#app")
</script>
</body>
</html>